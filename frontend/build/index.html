<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="manifest" href="/client/public/manifest.json">
    <meta name="theme-color" content="#2c2e3b">
    <link rel="apple-touch-icon" href="/client/public/apple-touch-icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Raspberry Pi Monitor - Charts & Analytics</title>
    <meta name="description" content="Historische Daten und Analysen für Raspberry Pi Systemüberwachung">
    
    <!-- Favicon & App Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/android-chrome-512x512.png">
    
    <!-- Chart.js - Multiple fallbacks -->
    <script>
        // Sequential loading for Chart.js to ensure proper order
        let loadedScripts = 0;
        const requiredScripts = 3;
        
        function checkAllLoaded() {
            if (++loadedScripts === requiredScripts) {
                console.log('✅ Alle Chart.js Scripts geladen');
                window.chartsReady = true;
            }
        }
        
        function loadScript(src, onLoad) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = onLoad;
            script.onerror = function() {
                console.error('❌ Fehler beim Laden von:', src);
                onLoad(); // Continue anyway
            };
            document.head.appendChild(script);
        }
        
        // Load scripts in sequence to ensure proper initialization
        loadScript('https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js', () => {
            loadScript('https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js', () => {
                loadScript('https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js', () => {
                    console.log('✅ Alle Chart.js Scripts geladen');
                    window.chartsReady = true;
                });
            });
        });
    </script>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2B2E3B">
    <meta name="color-scheme" content="dark">
    <meta name="application-name" content="Raspi Monitor">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Raspi Monitor">
    <meta name="mobile-web-app-capable" content="yes">
    
    <style>
        :root {
            /* Fog-Controller Farbschema */
            --background-dark: #2B2E3B;
            --background-darker: #252830;
            --card-background: #343845;
            --accent-blue: #688db1;
            --accent-green: #9cb68f;
            --accent-red: #e16162;
            --accent-orange: #e4a853;
            --accent-purple: #7c3aed;
            --text-primary: #d1d5db;
            --text-secondary: #9ca3af;
            --border-color: rgba(255, 255, 255, 0.1);
            
            /* Chart Colors */
            --chart-cpu: #688db1;
            --chart-memory: #9cb68f;
            --chart-disk: #e4a853;
            --chart-network: #7c3aed;
            --chart-temp: #e16162;
            
            /* Schatten */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.25);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
            
            /* Abstände */
            --spacing-1: 0.25rem;
            --spacing-2: 0.5rem;
            --spacing-3: 0.75rem;
            --spacing-4: 1rem;
            --spacing-6: 1.5rem;
            --spacing-8: 2rem;
            
            /* Rundungen */
            --radius: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            
            /* Font */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Inconsolata', 'Fira Code', monospace;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-family);
            background-color: var(--background-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background-color: var(--background-darker);
            padding: var(--spacing-6);
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background-color: rgba(37, 40, 48, 0.95);
        }
        
        .header h1 {
            font-size: 1.875rem;
            font-weight: 700;
            text-align: center;
            color: var(--text-primary);
            margin-bottom: var(--spacing-2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-3);
        }
        
        .header-subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-top: var(--spacing-2);
        }
        
        /* Navigation */
        .nav {
            display: flex;
            justify-content: center;
            gap: var(--spacing-4);
            margin-top: var(--spacing-4);
        }
        
        .nav a {
            color: var(--text-secondary);
            text-decoration: none;
            padding: var(--spacing-2) var(--spacing-4);
            border-radius: var(--radius);
            transition: all 0.3s ease;
        }
        
        .nav a:hover, .nav a.active {
            background: var(--accent-blue);
            color: white;
        }
        
        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-6);
            width: 100%;
            box-sizing: border-box;
            flex: 1;
        }
        
        /* Time Range Selector */
        .time-range-selector {
            background: var(--card-background);
            padding: var(--spacing-4);
            border-radius: var(--radius-xl);
            margin-bottom: var(--spacing-6);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }
        
        .time-range-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-2);
            justify-content: center;
            align-items: center;
        }
        
        .time-range-btn {
            background: var(--background-darker);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: var(--spacing-2) var(--spacing-4);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }
        
        .time-range-btn:hover {
            background: var(--accent-blue);
            color: white;
        }
        
        .time-range-btn.active {
            background: var(--accent-blue);
            color: white;
            box-shadow: var(--shadow);
        }
        
        /* Cards */
        .card {
            background-color: var(--card-background);
            border-radius: var(--radius-xl);
            padding: var(--spacing-6);
            margin-bottom: var(--spacing-6);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }
        
        .card h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: var(--spacing-4);
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        /* Chart Container */
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: var(--spacing-4);
        }
        
        .chart-container.small {
            height: 250px;
        }
        
        .chart-container.large {
            height: 500px;
        }
        
        /* Stats Grid */
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }
        
        .stat-summary-card {
            background: var(--background-darker);
            padding: var(--spacing-4);
            border-radius: var(--radius-lg);
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .stat-summary-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-1);
        }
        
        .stat-summary-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-summary-detail {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: var(--spacing-2);
        }
        
        /* Power Consumption */
        .power-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-4);
        }
        
        .power-estimate {
            background: var(--background-darker);
            padding: var(--spacing-4);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }
        
        .power-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-orange);
            margin-bottom: var(--spacing-2);
        }
        
        .power-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: var(--spacing-3);
        }
        
        .power-breakdown {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        
        .power-breakdown div {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing-1);
        }
        
        /* Loading */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: var(--text-secondary);
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-blue);
            animation: spin 1s ease-in-out infinite;
            margin-right: var(--spacing-3);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Footer */
        .footer {
            margin-top: auto;
            padding: var(--spacing-8) var(--spacing-6);
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--background-darker);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-4);
                max-width: 100%;
                overflow-x: hidden;
            }
            
            .time-range-buttons {
                flex-direction: column;
                align-items: stretch;
                gap: var(--spacing-2);
            }
            
            .time-range-btn {
                text-align: center;
                width: 100%;
            }
            
            .chart-container {
                height: 300px;
                width: 100%;
                overflow-x: hidden;
            }
            
            .power-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-summary {
                grid-template-columns: 1fr;
                gap: var(--spacing-3);
            }
            
            .card {
                padding: var(--spacing-4);
                margin-bottom: var(--spacing-4);
            }
            
            .nav {
                gap: var(--spacing-2);
                flex-wrap: wrap;
            }
            
            .nav a {
                padding: var(--spacing-2) var(--spacing-3);
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>
            <span>📈</span>
            <span>Raspberry Pi Monitor</span>
        </h1>
        <p class="header-subtitle">
            Historische Daten & Analysen
        </p>
        <nav class="nav">
            <a href="/">🏠 Dashboard</a>
            <a href="/charts.html" class="active">📈 Charts</a>
        </nav>
    </header>
    
    <div class="container">
        <!-- Time Range Selector -->
        <div class="time-range-selector">
            <div class="time-range-buttons">
                <button class="time-range-btn active" data-range="1h">Letzte Stunde</button>
                <button class="time-range-btn" data-range="6h">Letzte 6 Stunden</button>
                <button class="time-range-btn" data-range="24h">Letzte 24 Stunden</button>
                <button class="time-range-btn" data-range="7d">Letzte Woche</button>
                <button class="time-range-btn" data-range="30d">Letzter Monat</button>
            </div>
        </div>
        
        <!-- Summary Stats -->
        <div class="stats-summary" id="summary-stats">
            <div class="stat-summary-card">
                <div class="stat-summary-value" id="avg-cpu">--</div>
                <div class="stat-summary-label">Ø CPU</div>
                <div class="stat-summary-detail">Max: <span id="max-cpu">--</span></div>
            </div>
            <div class="stat-summary-card">
                <div class="stat-summary-value" id="avg-memory">--</div>
                <div class="stat-summary-label">Ø Memory</div>
                <div class="stat-summary-detail">Max: <span id="max-memory">--</span></div>
            </div>
            <div class="stat-summary-card">
                <div class="stat-summary-value" id="avg-temp">--</div>
                <div class="stat-summary-label">Ø Temperatur</div>
                <div class="stat-summary-detail">Max: <span id="max-temp">--</span></div>
            </div>
            <div class="stat-summary-card">
                <div class="stat-summary-value" id="power-estimate">--</div>
                <div class="stat-summary-label">Geschätzte Leistung</div>
                <div class="stat-summary-detail">Pro Tag: <span id="power-daily">--</span></div>
            </div>
        </div>
        
        <!-- CPU Usage Chart -->
        <div class="card">
            <h2>💻 CPU Auslastung</h2>
            <div class="chart-container">
                <canvas id="cpu-usage-chart"></canvas>
            </div>
        </div>
        
        <!-- CPU Temperature Chart -->
        <div class="card">
            <h2>🌡️ CPU Temperatur</h2>
            <div class="chart-container">
                <canvas id="cpu-temp-chart"></canvas>
            </div>
        </div>
        
        <!-- Memory Chart -->
        <div class="card">
            <h2>🧠 Arbeitsspeicher</h2>
            <div class="chart-container">
                <canvas id="memory-chart"></canvas>
            </div>
        </div>
        
        <!-- Network Chart -->
        <div class="card">
            <h2>🌐 Netzwerk Traffic</h2>
            <div class="chart-container">
                <canvas id="network-chart"></canvas>
            </div>
        </div>
        
        <!-- Power Consumption -->
        <div class="card">
            <h2>⚡ Stromverbrauch Schätzung</h2>
            <div class="power-grid">
                <div class="power-estimate">
                    <div class="power-value" id="current-power">--</div>
                    <div class="power-label">Aktuelle Leistung</div>
                    <div class="power-breakdown">
                        <div><span>CPU:</span> <span id="power-cpu">--</span></div>
                        <div><span>GPU:</span> <span id="power-gpu">--</span></div>
                        <div><span>RAM:</span> <span id="power-ram">--</span></div>
                        <div><span>I/O:</span> <span id="power-io">--</span></div>
                    </div>
                </div>
                <div class="power-estimate">
                    <div class="power-value" id="daily-power">--</div>
                    <div class="power-label">Täglicher Verbrauch</div>
                    <div class="power-breakdown">
                        <div><span>kWh/Tag:</span> <span id="daily-kwh">--</span></div>
                        <div><span>Kosten/Tag:</span> <span id="daily-cost">--</span></div>
                        <div><span>Monat:</span> <span id="monthly-cost">--</span></div>
                        <div><span>Jahr:</span> <span id="yearly-cost">--</span></div>
                    </div>
                </div>
            </div>
            <div class="chart-container small">
                <canvas id="power-chart"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        class ChartDashboard {
            constructor() {
                this.currentRange = '1h';
                this.charts = {};
                this.refreshInterval = 30000; // 30 Sekunden
                this.electricityRate = 0.32; // €/kWh - anpassbar
                this.isLoading = false;
                this.initialized = false;
                
                // Start initialization immediately
                this.init();
            }
            
            async waitForDependencies() {
                // Simple retry mechanism
                let attempts = 0;
                const maxAttempts = 50;
                
                while (attempts < maxAttempts) {
                    if (typeof Chart !== 'undefined' && typeof moment !== 'undefined' && window.chartsReady) {
                        console.log('✅ Chart.js loaded successfully');
                        
                        // Register time scale adapter for Chart.js v3
                        if (typeof Chart.register === 'function') {
                            try {
                                // Chart.js v3 - register all required components
                                Chart.register(
                                    Chart.CategoryScale,
                                    Chart.LinearScale,
                                    Chart.TimeScale,
                                    Chart.PointElement,
                                    Chart.LineElement,
                                    Chart.Title,
                                    Chart.Tooltip,
                                    Chart.Legend
                                );
                                console.log('✅ Chart.js components registered');
                            } catch (error) {
                                console.warn('⚠️ Chart.js component registration failed:', error);
                            }
                        }
                        
                        // Verify that the adapter is available
                        if (Chart._adapters && Chart._adapters._date) {
                            console.log('✅ Date adapter available');
                        } else {
                            console.warn('⚠️ Date adapter not found, will use fallback');
                        }
                        
                        this.fallbackMode = false;
                        return true;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                console.warn('⚠️ Chart.js not loaded, using fallback mode');
                this.fallbackMode = true;
                return false;
            }
            
            async init() {
                if (this.initialized) return;
                
                console.log('🚀 Initializing ChartDashboard...');
                
                // Wait for dependencies to load
                await this.waitForDependencies();
                
                // Setup UI
                this.setupEventListeners();
                
                // Load initial data
                await this.loadData();
                
                // Start refresh interval
                setInterval(() => this.loadData(), this.refreshInterval);
                
                this.initialized = true;
                console.log('✅ ChartDashboard initialized successfully');
            }
            
            setupEventListeners() {
                // Time range buttons
                document.querySelectorAll('.time-range-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.time-range-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentRange = e.target.dataset.range;
                        this.loadData();
                    });
                });
            }
            
            getTimeRange() {
                const now = new Date();
                let start;
                
                switch (this.currentRange) {
                    case '1h':
                        start = new Date(now.getTime() - 60 * 60 * 1000);
                        break;
                    case '6h':
                        start = new Date(now.getTime() - 6 * 60 * 60 * 1000);
                        break;
                    case '24h':
                        start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        break;
                    case '7d':
                        start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '30d':
                        start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        start = new Date(now.getTime() - 60 * 60 * 1000);
                }
                
                return `${start.toISOString()},${now.toISOString()}`;
            }
            
            async loadData() {
                if (this.isLoading) {
                    console.log('🔄 Bereits am Laden...');
                    return;
                }
                
                this.isLoading = true;
                
                try {
                    console.log('📡 Lade Daten für Zeitraum:', this.currentRange);
                    const range = this.getTimeRange();
                    const limit = this.currentRange === '1h' ? 60 : 
                                 this.currentRange === '6h' ? 360 : 
                                 this.currentRange === '24h' ? 1440 : 
                                 this.currentRange === '7d' ? 10080 : 43200;
                    
                    const [cpuData, memoryData, networkData, summaryData] = await Promise.all([
                        this.fetchMetrics('cpu', range, limit),
                        this.fetchMetrics('memory', range, limit),
                        this.fetchMetrics('network', range, limit),
                        this.fetchSummary()
                    ]);
                    
                    console.log('✅ Daten geladen:', {
                        cpu: cpuData.length,
                        memory: memoryData.length,
                        network: networkData.length
                    });
                    
                    this.updateCharts(cpuData, memoryData, networkData);
                    this.updateSummary(summaryData);
                    this.calculatePowerConsumption(cpuData, memoryData);
                    
                } catch (error) {
                    console.error('❌ Fehler beim Laden der Daten:', error);
                    this.showError('Fehler beim Laden der Daten: ' + error.message);
                } finally {
                    this.isLoading = false;
                }
            }
            
            showError(message) {
                // Show error in all chart containers
                ['cpu-chart', 'memory-chart', 'network-chart'].forEach(id => {
                    const container = document.getElementById(id);
                    if (container) {
                        container.innerHTML = `
                            <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #e16162;">
                                <div style="text-align: center;">
                                    <div style="font-size: 2rem; margin-bottom: 1rem;">⚠️</div>
                                    <div>${message}</div>
                                </div>
                            </div>
                        `;
                    }
                });
            }
            
            async fetchMetrics(type, range, limit) {
                const response = await fetch(`/api/metrics/${type}?range=${range}&limit=${limit}`);
                return await response.json();
            }
            
            async fetchSummary() {
                const hours = this.currentRange === '1h' ? 1 : 
                             this.currentRange === '6h' ? 6 : 
                             this.currentRange === '24h' ? 24 : 
                             this.currentRange === '7d' ? 168 : 720;
                
                const response = await fetch(`/api/metrics/summary?hours=${hours}`);
                return await response.json();
            }
            
            updateCharts(cpuData, memoryData, networkData) {
                if (this.fallbackMode || typeof Chart === 'undefined') {
                    console.log('🔄 Verwende Fallback-Charts');
                    this.createFallbackCharts(cpuData, memoryData, networkData);
                } else {
                    console.log('📊 Verwende Chart.js');
                    this.createCPUUsageChart(cpuData);
                    this.createCPUTemperatureChart(cpuData);
                    this.createMemoryChart(memoryData);
                    this.createNetworkChart(networkData);
                }
            }
            
            createFallbackCharts(cpuData, memoryData, networkData) {
                // Simple HTML/CSS charts as fallback
                this.createSimpleChart('cpu-usage-chart', cpuData.map(d => parseFloat(d.cpu_usage_percent)), 'CPU %', '#688db1');
                this.createSimpleChart('cpu-temp-chart', cpuData.map(d => parseFloat(d.cpu_temp_celsius)), 'CPU Temperatur °C', '#e16162');
                this.createSimpleChart('memory-chart', memoryData.map(d => parseFloat(d.usage_percent)), 'Memory %', '#9cb68f');
                
                if (networkData.length > 0) {
                    const networkValues = networkData.map(d => (parseInt(d.bytes_sent) + parseInt(d.bytes_recv)) / 1024 / 1024);
                    this.createSimpleChart('network-chart', networkValues, 'Network MB', '#7c3aed');
                }
            }
            
            createSimpleChart(containerId, values, label, color) {
                const container = document.getElementById(containerId);
                if (!container || !values.length) return;
                
                const maxValue = Math.max(...values);
                const minValue = Math.min(...values);
                
                let html = `
                    <div style="padding: 20px; background: var(--background-darker); border-radius: 8px;">
                        <h3 style="color: ${color}; margin-bottom: 15px;">${label}</h3>
                        <div style="display: flex; align-items: end; height: 200px; gap: 2px; border-bottom: 1px solid var(--border-color);">
                `;
                
                values.forEach((value, index) => {
                    const height = maxValue > 0 ? (value / maxValue) * 100 : 0;
                    html += `
                        <div style="
                            background: ${color}; 
                            height: ${height}%; 
                            flex: 1; 
                            min-width: 2px; 
                            border-radius: 2px 2px 0 0;
                            opacity: 0.8;
                        " title="${value.toFixed(1)}"></div>
                    `;
                });
                
                html += `
                        </div>
                        <div style="text-align: center; margin-top: 10px; color: var(--text-secondary);">
                            Min: ${minValue.toFixed(1)} | Max: ${maxValue.toFixed(1)} | Avg: ${(values.reduce((a, b) => a + b, 0) / values.length).toFixed(1)}
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            }
            
            createCPUUsageChart(data) {
                const ctx = document.getElementById('cpu-usage-chart').getContext('2d');
                
                if (this.charts.cpuUsage) {
                    this.charts.cpuUsage.destroy();
                }
                
                const labels = data.map(d => new Date(d.timestamp));
                const cpuUsage = data.map(d => parseFloat(d.cpu_usage_percent));
                
                this.charts.cpuUsage = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'CPU Auslastung (%)',
                            data: cpuUsage,
                            borderColor: '#688db1',
                            backgroundColor: 'rgba(104, 141, 177, 0.1)',
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'DD.MM.YYYY HH:mm',
                                    displayFormats: {
                                        hour: 'HH:mm',
                                        day: 'DD.MM',
                                        week: 'DD.MM',
                                        month: 'MM.YYYY'
                                    }
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    maxTicksLimit: 10
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'CPU Auslastung (%)',
                                    color: '#9ca3af'
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                min: 0,
                                max: 100
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }
            
            createCPUTemperatureChart(data) {
                const ctx = document.getElementById('cpu-temp-chart').getContext('2d');
                
                if (this.charts.cpuTemp) {
                    this.charts.cpuTemp.destroy();
                }
                
                const labels = data.map(d => new Date(d.timestamp));
                const cpuTemp = data.map(d => parseFloat(d.cpu_temp_celsius));
                
                this.charts.cpuTemp = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'CPU Temperatur (°C)',
                            data: cpuTemp,
                            borderColor: '#e16162',
                            backgroundColor: 'rgba(225, 97, 98, 0.1)',
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'DD.MM.YYYY HH:mm',
                                    displayFormats: {
                                        hour: 'HH:mm',
                                        day: 'DD.MM',
                                        week: 'DD.MM',
                                        month: 'MM.YYYY'
                                    }
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    maxTicksLimit: 10
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Temperatur (°C)',
                                    color: '#9ca3af'
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    callback: function(value) {
                                        return value + '°C';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                min: 20,
                                max: 85
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }
            
            createMemoryChart(data) {
                const ctx = document.getElementById('memory-chart').getContext('2d');
                
                if (this.charts.memory) {
                    this.charts.memory.destroy();
                }
                
                const labels = data.map(d => new Date(d.timestamp));
                const memoryUsage = data.map(d => parseFloat(d.usage_percent));
                const swapUsage = data.map(d => parseFloat(d.swap_usage_percent));
                
                this.charts.memory = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'RAM Auslastung (%)',
                            data: memoryUsage,
                            borderColor: '#9cb68f',
                            backgroundColor: 'rgba(156, 182, 143, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 6
                        }, {
                            label: 'Swap Auslastung (%)',
                            data: swapUsage,
                            borderColor: '#e4a853',
                            backgroundColor: 'rgba(228, 168, 83, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'DD.MM.YYYY HH:mm',
                                    displayFormats: {
                                        hour: 'HH:mm',
                                        day: 'DD.MM',
                                        week: 'DD.MM',
                                        month: 'MM.YYYY'
                                    }
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    maxTicksLimit: 10
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Speicher %',
                                    color: '#9ca3af'
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                min: 0,
                                max: 100
                            }
                        }
                    }
                });
            }
            
            createNetworkChart(data) {
                const ctx = document.getElementById('network-chart').getContext('2d');
                
                if (this.charts.network) {
                    this.charts.network.destroy();
                }
                
                const labels = data.map(d => new Date(d.timestamp));
                const bytesSent = data.map(d => parseInt(d.bytes_sent) / 1024 / 1024); // MB
                const bytesRecv = data.map(d => parseInt(d.bytes_recv) / 1024 / 1024); // MB
                
                this.charts.network = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Gesendet (MB)',
                            data: bytesSent,
                            borderColor: '#7c3aed',
                            backgroundColor: 'rgba(124, 58, 237, 0.1)',
                            fill: true,
                            tension: 0.3
                        }, {
                            label: 'Empfangen (MB)',
                            data: bytesRecv,
                            borderColor: '#688db1',
                            backgroundColor: 'rgba(104, 141, 177, 0.1)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'DD.MM.YYYY HH:mm',
                                    displayFormats: {
                                        hour: 'HH:mm',
                                        day: 'DD.MM',
                                        week: 'DD.MM',
                                        month: 'MM.YYYY'
                                    }
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    maxTicksLimit: 10
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Netzwerk MB',
                                    color: '#9ca3af'
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    callback: function(value) {
                                        return value.toFixed(1) + ' MB';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            }
                        }
                    }
                });
            }
            
            updateSummary(data) {
                console.log('updateSummary called with data:', data);
                
                if (data && data.cpu) {
                    const avgCpu = data.cpu.avg_value;
                    const maxCpu = data.cpu.max_value;
                    const avgTemp = data.cpu.avg_temp;
                    const maxTemp = data.cpu.max_temp;
                    
                    console.log('CPU values:', { avgCpu, maxCpu, avgTemp, maxTemp });
                    
                    document.getElementById('avg-cpu').textContent = avgCpu ? `${parseFloat(avgCpu).toFixed(1)}%` : '--';
                    document.getElementById('max-cpu').textContent = maxCpu ? `${parseFloat(maxCpu).toFixed(1)}%` : '--';
                    document.getElementById('avg-temp').textContent = avgTemp ? `${parseFloat(avgTemp).toFixed(1)}°C` : '--';
                    document.getElementById('max-temp').textContent = maxTemp ? `${parseFloat(maxTemp).toFixed(1)}°C` : '--';
                } else {
                    console.log('No CPU data found');
                }
                
                if (data && data.memory) {
                    const avgMemory = data.memory.avg_value;
                    const maxMemory = data.memory.max_value;
                    
                    console.log('Memory values:', { avgMemory, maxMemory });
                    
                    document.getElementById('avg-memory').textContent = avgMemory ? `${parseFloat(avgMemory).toFixed(1)}%` : '--';
                    document.getElementById('max-memory').textContent = maxMemory ? `${parseFloat(maxMemory).toFixed(1)}%` : '--';
                } else {
                    console.log('No memory data found');
                }
            }
            
            calculatePowerConsumption(cpuData, memoryData) {
                if (!cpuData.length || !memoryData.length) return;
                
                const latestCpu = cpuData[0];
                const latestMemory = memoryData[0];
                
                // Raspberry Pi 4 Stromverbrauch Schätzung
                const basePower = 2.5; // Grundverbrauch in Watt
                const cpuPower = (parseFloat(latestCpu.cpu_usage_percent) / 100) * 1.5; // CPU Last
                const memoryPower = (parseFloat(latestMemory.usage_percent) / 100) * 0.5; // RAM Last
                const gpuPower = 0.5; // GPU Grundverbrauch
                const ioPower = 0.5; // I/O Grundverbrauch
                
                const totalPower = basePower + cpuPower + memoryPower + gpuPower + ioPower;
                
                // Berechnungen
                const dailyWh = totalPower * 24; // Wh pro Tag
                const dailyKwh = dailyWh / 1000; // kWh pro Tag
                const dailyCost = dailyKwh * this.electricityRate; // Kosten pro Tag
                const monthlyCost = dailyCost * 30; // Kosten pro Monat
                const yearlyCost = dailyCost * 365; // Kosten pro Jahr
                
                // UI Update
                document.getElementById('current-power').textContent = `${totalPower.toFixed(1)}W`;
                document.getElementById('power-cpu').textContent = `${cpuPower.toFixed(1)}W`;
                document.getElementById('power-gpu').textContent = `${gpuPower.toFixed(1)}W`;
                document.getElementById('power-ram').textContent = `${memoryPower.toFixed(1)}W`;
                document.getElementById('power-io').textContent = `${ioPower.toFixed(1)}W`;
                
                document.getElementById('daily-power').textContent = `${dailyWh.toFixed(0)}Wh`;
                document.getElementById('daily-kwh').textContent = `${dailyKwh.toFixed(3)}`;
                document.getElementById('daily-cost').textContent = `${dailyCost.toFixed(2)}€`;
                document.getElementById('monthly-cost').textContent = `${monthlyCost.toFixed(2)}€`;
                document.getElementById('yearly-cost').textContent = `${yearlyCost.toFixed(2)}€`;
                
                document.getElementById('power-estimate').textContent = `${totalPower.toFixed(1)}W`;
                document.getElementById('power-daily').textContent = `${dailyKwh.toFixed(3)} kWh`;
                
                // Power Chart
                if (this.fallbackMode || typeof Chart === 'undefined') {
                    const powerData = cpuData.map((cpu, index) => {
                        const memory = memoryData[index];
                        if (!memory) return 0;
                        
                        const basePower = 2.5;
                        const cpuPower = (parseFloat(cpu.cpu_usage_percent) / 100) * 1.5;
                        const memoryPower = (parseFloat(memory.usage_percent) / 100) * 0.5;
                        
                        return basePower + cpuPower + memoryPower + 1.0;
                    });
                    
                    this.createSimpleChart('power-chart', powerData, 'Power (W)', '#e4a853');
                } else {
                    this.createPowerChart(cpuData, memoryData);
                }
            }
            
            createPowerChart(cpuData, memoryData) {
                const ctx = document.getElementById('power-chart').getContext('2d');
                
                if (this.charts.power) {
                    this.charts.power.destroy();
                }
                
                const labels = cpuData.map(d => new Date(d.timestamp));
                const powerData = cpuData.map((cpu, index) => {
                    const memory = memoryData[index];
                    if (!memory) return 0;
                    
                    const basePower = 2.5;
                    const cpuPower = (parseFloat(cpu.cpu_usage_percent) / 100) * 1.5;
                    const memoryPower = (parseFloat(memory.usage_percent) / 100) * 0.5;
                    
                    return basePower + cpuPower + memoryPower + 1.0; // +1W für GPU/IO
                });
                
                this.charts.power = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Leistungsaufnahme (W)',
                            data: powerData,
                            borderColor: '#e4a853',
                            backgroundColor: 'rgba(228, 168, 83, 0.2)',
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    tooltipFormat: 'DD.MM.YYYY HH:mm',
                                    displayFormats: {
                                        hour: 'HH:mm',
                                        day: 'DD.MM',
                                        week: 'DD.MM',
                                        month: 'MM.YYYY'
                                    }
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    maxTicksLimit: 8
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Leistung (W)',
                                    color: '#9ca3af'
                                },
                                ticks: { 
                                    color: '#9ca3af',
                                    callback: function(value) {
                                        return value.toFixed(1) + ' W';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            }
                        }
                    }
                });
            }
        }
        
        // Initialize Dashboard
        let dashboard = null;
        let initAttempts = 0;
        const maxInitAttempts = 10;
        
        function initializeDashboard() {
            if (dashboard) return; // Already initialized
            
            console.log(`🔄 Initialization attempt ${initAttempts + 1}/${maxInitAttempts}`);
            
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                dashboard = new ChartDashboard();
                console.log('✅ Dashboard created successfully');
            } else if (initAttempts < maxInitAttempts) {
                initAttempts++;
                setTimeout(initializeDashboard, 200);
            } else {
                console.error('❌ Failed to initialize dashboard after maximum attempts');
            }
        }
        
        // Multiple initialization triggers
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDashboard);
        } else {
            // DOM is already ready
            initializeDashboard();
        }
        
        // Fallback for window load event
        window.addEventListener('load', initializeDashboard);
    </script>
    
    <!-- Footer -->
    <footer class="footer">
        Made with ❤️ by Martin Pfeffer
    </footer>
    <script>
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/client/public/service-worker.js")
            .then(reg => console.log("Service Worker registered"))
            .catch(err => console.log("Service Worker registration failed"));
    }
    </script>
</body>
</html>